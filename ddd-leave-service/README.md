# DDD 实现请假考勤系统
> 未写完，Bug 一堆，参考下项目结构即可

## 业务流程
请假人填写请假单提交审批。根据请假人身份、请假类型和请假天数进行校验并确定审批规则。
根据审批规则确定审批人，逐级提交上级审批，逐级核批通过则完成审批，否则审批不通过则退回申请人

## 请假微服务采用的DDD设计思想
> > 请假微服务中用到了很多DDD设计思想和方法，主要包括以下几点。

1. 聚合的管理：聚合根、实体和值对象的关系。
2. 聚合数据的初始化和持久化：工厂和仓储模式。
3. 聚合的解耦：聚合代码的解耦、跨聚合的服务调用和对象解耦。
4. 领域事件管理：领域事件实体结构、持久化和事件发布。
5. DDD 分层架构：基础层、领域层、应用层和用户接口层的协作。
6. 服务的分层与协作：实体方法、领域服务、应用服务、接口服务，服务的组合和编排，跨多个聚合的服务管理和协同。
7. 对象的分层和转换：DTO、DO 和 PO 等对象在不同层的转换和实现过程。
8. 微服务之间的访问：登录和认证服务。

## 项目结构
### Interfaces (用户接口层)
它主要存放用户接口层与前端交互、展现数据相关的代码。前端应用通过这一层的接口，向应用服务获取展现所需的数据。
这一层主要用来处理用户发送 的 Restful 请求，解析用户输入的配置文件，并将数据传递给 Application 层。
数据的组装、数据传输格式以及 Facade 接口等代码都会放在这一层目录里

- Assembler: 实现 DTO 与领域对象之间的相互转换和数据交换。一般来说 Assembler 与 DTO 总是一同出现
- Dto: 它是数据传输的载体，内部不存在任何业务逻辑，我们可以通过 DTO 把内部的领域 对象与外界隔离
- Facade: 提供较粗粒度的调用接口，将用户请求委派给一个或多个应用服务进行处理

### Application (应用层)
它主要存放应用层服务组合和编排相关的代码。应用服务向下基于微服务内的领域服务或外部微服务的应用服务完成服务的编排和组合，
向上为用户接口层提供各种应用数据展现支持服务。应用服务和事件等代码会放在这一层目录里

- Event: 这层目录主要存放事件相关的代码。它包括两个子目录: publish 和 subscribe
  - 前者主要存放事件发布相关代码，后者主要存放事件订阅相关代码(事件处理 相关的核心业务逻辑在领域层实现)。
  - 虽然应用层和领域层都可以进行事件的发布和处理，但为了实现事件的统一管理，建议将微服务内所有事件的发布和订阅的处理都统一放到应用层，事件相关的核心业务逻辑实现放在领域层。通过应用层调用领域层服务，来实现完整的事件发布和订阅处理流程
- Service: 这层的服务是应用服务。应用服务会对多个领域服务或外部应用服 务进行封装、编排和组合，对外提供粗粒度的服务。应用服务主要实现服务组合和编排，是 一段独立的业务逻辑。你可以将所有应用服务放在一个应用服务类里，也可以把一个应用服务设计为一个应用服务类，以防应用服务类代码量过大
- Domain: 由一个或多个聚合包构成，共同实现领域模型的核心业务逻辑。聚合内的代码模型是标准和统一的，包括: entity、event、repository 和 service 四个子目录

### Domain (领域层)
它主要存放领域层核心业务逻辑相关的代码。领域层可以包含多个聚合代码包，它们共同实现领域模型的核心业务逻辑。
聚合以及聚合内的实体、方法、领域服 务和事件等代码会放在这一层目录里


Domain 是由一个或多个聚合包构成，共同实现领域模型的核心业务逻辑。
聚合内的代码 模型是标准和统一的，包括:entity、event、repository 和 service 四个子目录

- Aggregate(聚合): 它是聚合软件包的根目录，可以根据实际项目的聚合名称命名，比如权限聚合。在聚合内定义聚合根、实体和值对象以及领域服务之间的关系和边界。聚合内实现高内聚的业务逻辑，它的代码可以独立拆分为微服务。以聚合为单位的代码放在一个包里的主要目的是为了业务内聚，而更大的目的是为了以后微服务之间聚合的重组。聚合之间清晰的代码边界，可以让你轻松地实现以聚合为单位的微服务重组，在微服务架构演进中有着很重要的作用
  - Entity: 它存放聚合根、实体、值对象以及工厂模式 (Factory) 相关代码。实体类采用充血模型，同一实体相关的业务逻辑都在实体类代码中实现。跨实体的业务逻辑代码在领域服务中实现
  - Event: 它存放事件实体以及与事件活动相关的业务逻辑代码
  - Service(领域服务): 它存放领域服务代码。一个领域服务是多个实体组合出来的一段业务逻辑。可以将聚合内所有领域服务都放在一个领域服务类中，你也可以把每一个领域服务设计为一个类。
    - 如果领域服务内的业务逻辑相对复杂，建议将一个领域服务设计为一个领域服务类，避免由于所有领域服务代码都放在一个领域服务类中，而出现代码臃肿的问题。领域服务封装多个实体或方法后向上层提供应用服务调用
  - Repository(仓储): 它存放所在聚合的查询或持久化领域对象的代码，通常包括仓储接口和仓储实现方法。为了方便聚合的拆分和组合，我们设定了一个原则: **一个聚合对应一个仓储**
    - 按照 DDD 分层架构，仓储实现本应该属于基础层代码，但为了在微服务架构演进时，保证代码拆分和重组的便利性，我是把聚合仓储实现的代码放到了聚合包内。这样，如果需求或者设计发生变化导致聚合需要拆分或重组时，我们就可以将包括核心业务逻辑和仓储代码的聚合包整体迁移，轻松实现微服务架构演进

### Infrastructure (基础层)
它主要存放基础资源服务相关的代码，为其它各层提供的通用 技术能力、三方软件包、数据库服务、配置和基础资源服务的代码都会放在这一层目录里

- Config: 主要存放配置相关代码
- Util: 主要存放平台、开发框架、消息、数据库、缓存、文件、总线、网关、第三方类库、通用算法等基础代码，你可以为不同的资源类别建立不同的子目录

## 调用流程 (创建用户请求为例)
1. 用户接口层
   1. Assembler: 将 dto 转换为 entity
   2. Dto: 接收请求传入的数据 dto
   3. Facade: 调用应用层创建用户的方法
2. 应用层
   1. Event: 发布用户创建事件给其他微服务
   2. Service: 
      1. 内部服务: 创建用户
      2. 外部服务: 添加日志
3. 领域层
   1. Aggregate: 对应的聚合目录 (例: UserAggregate)
      1. Entity: 用户聚合根
      2. Event: 创建用户事件
      3. Service: 具体的创建用户逻辑
      4. Repository: 与数据库交互, 保存用户信息